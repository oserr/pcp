\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{backnaur}
\usepackage[scaled]{beramono}
\usepackage{bm}
\usepackage[small,bf]{caption}
\usepackage[strict]{changepage}
\usepackage{dblfloatfix}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{flushend}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{ifsym}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{mathrsfs}
\usepackage{multirow}
\usepackage{pdfpages}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{textcomp}
\usepackage[hyphens]{url}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{pgfgantt}
\usepackage{wrapfig}
\usepackage{balance}
\usepackage{tikz}
\usetikzlibrary{shapes,decorations}
\usepackage{pgfplots}
\usepgfplotslibrary{units}
\pgfplotsset{compat=1.14}
\usepackage{bm}
\usepackage[
backend=biber,
style=ieee
]{biblatex}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
%\bibliographystyle{IEEEtran}
%\bibliographystyle{acm}
\addbibresource{references.bib}

\addtolength{\evensidemargin}{-.5in}
\addtolength{\oddsidemargin}{-.5in}
\addtolength{\textwidth}{0.8in}
\addtolength{\textheight}{0.8in}
\addtolength{\topmargin}{-.4in}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\vspace{-25pt}
\huge CS 15-618 Project Proposal \\
\huge Synchrony
}
\author{
    Patricio Chilano (pchilano) \\
    Omar Serrano (oserrano)
}
\date{\today}

\begin{document}

\definecolor{beaublue}{rgb}{0.74, 0.83, 0.9}

\lstset{
    language=C++,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{orange}\ttfamily,
    morecomment=[l][\color{magenta}]{\#},
    breaklines=true
}

\maketitle

\section*{Summary}
We are going to implement a concurrent doubly-linked list, and a hash map,
lock-free, and with coarse-grained and fine-grained locks, in order to
investigate how these concurrent data structures are implemented, and to study
first-hand how these techniques compare with each other on a variety of
different workloads.

\section*{Background}
Even though some parallel applications may get away without needing concurrent
data structures, arguably the more common paradigm is for threaded applications
to use them. Work queues, for example, are a good way for a server to model the
producer-consumer paradigm, as the server puts newly created connections into a
queue, and a pool of threads take items from the queue as they are added to it.
A parallel implementation of $A*$, for example, might need a concurrent priority
queue for nodes in the frontier, and a concurrent hash set to record the nodes
that have already been visited.

The common theme of these examples is the need for thread-safe data structures,
yet both present different use cases of concurrency, and hence the best type of
synchronization mechanism used by each application is different. The server is
well served by a blocking queue, because it may go through periods without
client requests. While it waits, the server can free up the CPU for other tasks.
If it is part of a distributed application, for example, it can send heartbeats
to other hosts, create a checkpoint, etc.

On the other hand, when $A*$ runs it will simply try to process a graph as
quickly as possible in order to find the best path from one node to the other.
Therefore, a parallel version of $A*$ that uses blocking concurrent data
structures may perform more poorly than one with lock-free data structures. When
a thread pops a node from the priority queue of nodes in the frontier, i.e.,
nodes yet-to-be explored, or inserts a node into the hash set of visited nodes,
it does quickly. If $A*$ uses blocking concurrent data structures, then the cost
of thread preemption and rescheduling by the OS is likely to dominate the cost
of synchronizing access to the data structures.

As these examples demonstrate, different applications are better suited for
different forms of synchronization. In addition to the particulars of an
application, other factors may affect the behavior of concurrent data structures
implemented with different synchronizatin mechanisms, such as the workload or
the number of processors and threads used.

\section*{Challenge}

\section*{Resources}

\section*{Goals and Deliverables}

\begin{itemize}
\item Doubly linked list (DLL) with
\begin{itemize}
\item coarse-grained locks
\item fined-grained locks
\item lock-free
\end{itemize}
\item Test harness for linked list
\item Hash map (HM) with
\begin{itemize}
\item coarse-grained locks
\item fined-grained locks
\item lock-free
\end{itemize}
\item test harness for hash map
\end{itemize}

\section*{Platform Choice}

\section*{Schedule}

\printbibliography

\begin{table}[t]
\begin{center}
\begin{tabular}{ll}
\toprule
\bf Week & \bf Deliverable   \\
\midrule
4/9      & DLL with coarse grained locks \\
         & DLL Test harness \\
4/16     & Check point 1 \\
         & DLL fined-grained locks \\
         & HM coarse-grained locks \\
         & HM test-harness \\
4/23     & Check point 2 \\
         & DLL lock-free \\
         & HM fine-grained \\
4/30     & HM lock-free \\
         & Report \\
\bottomrule
\end{tabular}
\caption{Weekly Schedule}
\label{table:shedule}
\end{center}
\end{table}

\end{document}
